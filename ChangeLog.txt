Change Log
==========

This is the Change Log for VDS.Common

1.6.0
-----

- Bloom Filter improvements
 - Refactored the interfaces slightly
 - Refactored base implementations for better code reuse
 - Three hashing approaches are now available:
  - Naive - the existing implementation that gives full control to devlopers
  - Fast - uses approach from http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.152.579&rep=rep1&type=pdf
  - Hybrid - uses a hybrid of the naive and fast approaches
- Collection improvements
 - ISparseArray now has a Clear() method
 - New DuplicateSortedList for cases where you need to have a sorted list that supports duplicate items
 - New Collections.Enumerations namespace with various useful enumerables and suitable extension methods for
   invoking these in fluent style
    - LongTake()
    - LongSkip()
    - AddIfMissing() - add an item if not present in another enumerable
    - AddIfEmpty() - add an item if the other enumerable is empty
    - Reduced() - eliminate adjacent duplicate elements
    - Top(), TopDistinct(), Bottom() and BottomDistinct() - efficiently yield only the N top/bottom items 
      optionally with distinctness
    - ProbabilisticDistinct() - true streaming distinct using bloom filters
- New Comparers namespaces
 - ReferenceEqualityComparer for when you need reference equality only
 - ReversedComparer for reversing the ordering given by another comparer
- Tree improvements
 - Better interface definition for binary trees
 - Support for indexed access into binary trees
- Trie improvements
 - Improved locking strategy for non-sparse tries to improve performance
- General improvements
 - Filled out missing XML doc comments
 - Improved test coverage

1.5.0
-----

- Improved Bloom Filter performance
- Switch to PCL Profile 328 as our PCL target

1.4.0
-----

- MaterializedImmutableView overrides Contains() to improve efficiency
- New ISparseArray interface
- Add ISparseArray implementations:
 - LinkedSparseArray - O(n) lookup with best memory efficiency
 - BlockSparseArray - O(1) lookup with least memory efficiency
 - BinarySparseArray - O(log n) lookup
- New IBloomFilter interface
- Add IBloomFilter implementations:
 - BloomFilter
 - SparseBloomFilter - Uses BlockSparseArray so more memory efficient for large numbers of bits

1.3.0
-----

- Switch to PCL Profile 136 as our PCL target
 - Removed SL4 and WP7 builds
- New IBoundedList interface
- Add IBoundedList implementations:
 - BoundedList
 - DiscardingBoundedList

1.2.0
-----

- Extract ITrie interface
 - Add Contains() and ContainsKey() methods to ITrie
- Add alternative ITrie implemenations
 - SparseReferenceTrie
 - SparseValueTrie
 - SparseCharacterTrie
 - SparseStringTrie
- Bug fix to problem where enumerating over a Trie would not reflect latest state of tree
- Bug fix to logic error in TryGetValue() on Tries
- Null Keys support for MultiDictionary must now be explicitly configured, mark constructors calls which should be updated as Obsolete

1.1.3
-----

- Correct NuGet package directory names for portable class library builds

1.1.2
-----

- Add TreeSortedDictionary
- Bug fix to problem where enumerable on BinaryTree would not reflect latest state of tree
- Bug fix to be more specific in error handling on the null keys check in MultiDictionary
- Add Portable Class Library builds

1.1.1
-----

- Include PDBs in NuGet packages

1.1.0
-----

- Fixes to MultiDictionary to align behaviour with standard .Net dictionary
- Added ImmutableView
- Changed behaviour of Add() on ITree to throw an error if duplicate key is added
- Fixes to BinaryTree to reflect ITree contract changes

1.0.2
-----

- Change how MultiDictionary handles null keys, disables null keys if hash function does not support them
- Make more classes public

1.0.1
-----

- Make some classes public which were previously internal

1.0.0
-----

- Corrected Namespaces
- Removed defunct HashTable code

0.9.0
-----

- Split out of original location in dotNetRDF